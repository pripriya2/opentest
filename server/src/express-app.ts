import * as bcrypt from 'bcryptjs';
import * as bodyParser from 'body-parser';
import * as buildInfo from './lib/build-info';
import * as configLoader from './lib/config-loader';
import * as apiRouter from './controllers/api';
import * as uiRouter from './controllers/ui';
import * as  express from 'express';
import * as favicon from 'serve-favicon';
import * as helpers from './lib/helpers';
import * as moment from 'moment';
import * as path from 'path';
import { sessionSettings } from './lib/express-session';
import * as yargs from 'yargs';

export function createApp(options?: any) {
	options = options || {};
	let expressApp: express.Express = express();

	expressApp.set('views', path.join(__dirname, 'views'));
	expressApp.engine('pug', require('pug').__express);
	expressApp.set('view engine', 'pug');

	expressApp.use(sessionSettings);
	expressApp.set('trust proxy', true);

	expressApp.use(bodyParser.json({ limit: '30mb' }));
	expressApp.use(bodyParser.urlencoded({ extended: true }));

	if (yargs.argv.trace) {
		expressApp.use(function (req, res, next) {
			var hasBody = (Object.keys(req.body).length > 0);
			console.log(helpers.format("{0} {1}://{2}{3}{4}",
				req.method,
				req.protocol,
				req.hostname,
				req.originalUrl,
				hasBody ? '\n' + JSON.stringify(req.body) : ''));
			next();
		});
	}

	const buildInfoObj = buildInfo.getBuildInfo();
	expressApp.locals.version = buildInfoObj.version;
	expressApp.locals.buildDate = buildInfoObj.buildDate;
	expressApp.locals.commitSha = buildInfoObj.commitSha;
	expressApp.locals.moment = moment;

	expressApp.use(function (req, res, next) {
		if (!(req.session as any).timezone) {
			(req.session as any).timezone = 'America/Chicago';
		}
		next();
	});

	// AUTHENTICATION MIDDLEWARE
	const authenticatedAccounts = {};
	expressApp.use(async (req, res, next) => {
		const config = configLoader.getConfig();

		if (!config.adminLogin || (!config.adminPassword && !config.adminPasswordBcrypt)) {
			return next();
		}

		// Extract username and password from Authorization header
		const b64auth = (req.headers.authorization || '').split(' ')[1] || '';
		const userAndPass = Buffer.from(b64auth, 'base64').toString();
		const colonIndex = userAndPass.indexOf(':');
		const userName = userAndPass.substring(0, colonIndex);
		const userPassword = userAndPass.substring(colonIndex + 1);

		let accountIsAuthenticated = authenticatedAccounts[userName] == userPassword;
		if (!accountIsAuthenticated) {
			if (config.adminPassword) {
				if (config.adminLogin === userName && config.adminPassword === userPassword) {
					accountIsAuthenticated = true;
					authenticatedAccounts[userName] = userPassword;
				}
			} else if (config.adminPasswordBcrypt) {
				let hashMatchesPassword = false;
				try {
					// Check user password against the hash value from config file
					hashMatchesPassword = await bcrypt.compare(userPassword, config.adminPasswordBcrypt);
				} catch {
					console.log('ERROR: Failed to validate password hash');
				}

				if (config.adminLogin === userName && hashMatchesPassword) {
					accountIsAuthenticated = true;
					authenticatedAccounts[userName] = userPassword;
				}
			}
		}

		if (accountIsAuthenticated) {
			return next();
		}

		res.set('WWW-Authenticate', 'Basic realm="OpenTest server"')
		res.status(401).send('Authentication failed')
	});

	const config = configLoader.getConfig();

	expressApp.use(config.urlPrefix, express.static(path.join(__dirname, 'public')));
	expressApp.use(config.urlPrefix, favicon(path.join(__dirname, 'public', 'favicon.ico')));

	expressApp.use(config.urlPrefix, uiRouter.createRouter(options));
	expressApp.use(`${config.urlPrefix}/api`, apiRouter.createRouter(options));

	return expressApp;
}